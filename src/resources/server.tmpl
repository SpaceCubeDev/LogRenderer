<!DOCTYPE html>
<html lang="en">
<head>
    <title>LogRenderer</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" href="{{ .UrlPrefix }}/res/favicon-png" type="image/png" sizes="any">

    <link rel="stylesheet" href="{{ .UrlPrefix }}/res/global-css">
    <link rel="stylesheet" href="{{ .UrlPrefix }}/res/server-css">

    <meta name="theme-color" content="#fafafa">
</head>
<body>
<div class="flex-box">
    {{ template "navbar" . -}}
    {{ $urlPrefix := .UrlPrefix }}
    <main>
        <div id="logs" class="logs">
            {{- range $logLine := .ServerLogs }}
                <div class="row">{{ $logLine }}</div>
            {{- end }}
        </div>
    </main>
</div>
<script>
    const searchInput = document.getElementById("search-input");
    const logsDiv = document.getElementById("logs");
    const lastUpdateSpan = document.getElementById("last-update");

    const inlineRegexps = {{ .SyntaxHighlightingRegexps }}.reverse();

    const twoDigits = d => d < 10 ? "0" + d : d;

    function handleLineFocus(target) {
        for (let i = 0; !target.classList.contains("row") && i < 10; i++) {
            target = target.parentElement;
        }
        const line = target;
        searchInput.value = "";
        handleSearch();
        line.classList.add("highlighted");
        line.scrollIntoView();
        setTimeout((row) => row.classList.remove("highlighted"), 2000, line);
    }

    function parseLine(line) {
        if (line.innerText.length === 0) {
            return line;
        }
        let lineText = line.textContent;
        for (const highlighter of inlineRegexps) {
            const field = highlighter.field;
            const regexp = new RegExp(highlighter.regex, "m");
            try {
                if (!regexp.test(lineText)) {
                    continue;
                }
                lineText = lineText.replace(regexp, `<span class="${field}">` + "$&" + "</span>");
            } catch (error) {
                console.error(field, regexp, line, error);
            }
        }
        line.innerHTML = lineText;
        line.addEventListener("click", ev => searchInput.value !== "" ? handleLineFocus(ev.target) : null);
        return line;
    }

    function isLogDivFullyScrolled() {
        return window.scrollY + window.innerHeight - logsDiv.getBoundingClientRect().top - logsDiv.offsetParent.getBoundingClientRect().top === logsDiv.scrollHeight;
    }

    function scrollToEnd() {
        if (logsDiv.firstChild != null) {
            logsDiv.lastElementChild.scrollIntoView();
        }
    }

    function handleEvent(data) {
        let event;
        try {
            event = JSON.parse(data);
        } catch (e) {
            console.error(e);
            console.log("EventData:", data);
            return;
        }
        // console.info(event);
        switch (event["type"]) {
            case "ADD":
                if (event["content"] && event["content"].length > 0) {
                    const newLine = document.createElement("div");
                    newLine.classList.add("row")
                    newLine.innerText = event["content"];
                    const mustScroll = isLogDivFullyScrolled();
                    logsDiv.appendChild(parseLine(newLine));
                    if (mustScroll) {
                        scrollToEnd();
                    }
                }
                break;
            case "RESET":
                console.warn("Reset !");
                while (logsDiv.hasChildNodes()) {
                    logsDiv.removeChild(logsDiv.firstChild);
                }
                break;
            default:
                console.warn("Unknown event:", event["type"]);
                break;
        }

        const date = new Date();
        lastUpdateSpan.innerText = `${twoDigits(date.getHours())}:${twoDigits(date.getMinutes())}:${twoDigits(date.getSeconds())}`;
    }

    function handleSearch() {
        const value = searchInput.value.toLowerCase();
        if (value === "") {
            document.querySelectorAll("main .row.hidden").forEach(row => row.classList.remove("hidden"));
        } else {
            document.querySelectorAll("main .row").forEach(row => {
                if (row.textContent.toLowerCase().includes(value)) {
                    row.classList.remove("hidden");
                } else {
                    row.classList.add("hidden");
                }
            });
        }
    }

    function updateWebsocketStatus(alive) {
        if (alive) {
            document.getElementById("websocket-status").classList.add("connected");
        } else {
            document.getElementById("websocket-status").classList.remove("connected");
        }
        // document.getElementById("websocket-status").style.backgroundColor = alive ? "green" : "red";
    }

    document.addEventListener("DOMContentLoaded", () => {
        searchInput.value = "";
        searchInput.addEventListener("input", handleSearch);
        searchInput.addEventListener("focusout", scrollToEnd);

        if (window["WebSocket"]) {
            const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
            const urlPrefix = '{{ $urlPrefix }}';
            const conn = new WebSocket(wsProtocol + "/\/" + location.host + urlPrefix + "/ws");

            conn.onclose = () => {
                updateWebsocketStatus(false);
                console.warn("WebSocket connection closed");
            }

            conn.onmessage = ev => {
                // console.log("WebSocket message:", ev);
                for (const data of ev.data.split('{{ .MessageSeparator }}')) {
                    if (data.length !== 0) {
                        handleEvent(data);
                    }
                }
            }

            updateWebsocketStatus(!!conn);

            if (!conn) {
                console.error("No WebSocket connection established");
                return;
            }

            function register() {
                if (conn.readyState === 1) {
                    conn.send('{{ .Server }}');
                    return;
                }
                setTimeout(register, 100);
            }

            register();

            logsDiv.querySelectorAll("div.row").forEach(line => parseLine(line));
            scrollToEnd();
        } else {
            updateWebsocketStatus(false);
            console.error("Your browser does not support WebSockets");
        }
    });
</script>
</body>
</html>